# Option

This package offers an `Option` generic type based on the `Option` type from Rust. All functions and methods in this package are named based on the methods found on the Rust type ([docs here](https://doc.rust-lang.org/stable/std/option/)).

## Usage

The only exported type of this package is `Option`, however this type should never be instantiated directly, but rather through the two constructors: `Some(t T)` or `None()`. The former represennts an Option with a value `t` of generic type `T`, and the latter represents the absense of a value. Using an `Option` allows for the idea of something being "nullable" without actually doing null checks or error checks, while keeping full type safety, and without using pointers to allow base types to be null.

To work with `Option`s, you will often inject functionality into the option type rather than immediately trying to pull the type out of the `Option`. For example, if you have a function that calls that may or may not return an `int`. Normally this would be implemented by either returning a `(int, error)` tuple where the error represents the lack of an `int`, or a `*int` could be used with `nil` as the return value when no `int` is present. Using these two paradigms if we wanted to double the value we would have to do something like the following:

```go
// Error method
func FirstCalculation() (int, error) {...}

v1, err := FirstCalculation()
if err != nil {
  return 0, err
}

return v1 * 2, nil

// Pointer method
func SomeCalculation() *int {...}

v1 := SomeCalculation()
if v1 == nil {
  return nil
}

return v1 * 2
```

In both of these cases, we have to propogate the means with which we checked this error despite having to manully handle the error ourselves. With an `Option`, we apply the logic into the `Option` itself like so:

```go
func SomeCalculation() Option[int] {...}

val := SomeCalculation()
doubled := option.Map(val, func(x int) int {x * 2})
return doubled // Option[int]
```

If `SomeCalculation` returned a value, we will double that value, otherwise we will automatically propogate the `None` which was returned. For exmaples on how to use each of the included functions/methods, check out the [Rust `std::option` docs](https://doc.rust-lang.org/stable/std/option/) which will have a very similar syntax.

## Functions vs Methods

Most features of this package are implemented as methods on an `Option`. However, due to the lack of generic methods on generic types in Go, some of the methods from the Rust library had to be implemented as package functions. The affected functions are:

- `Map`
- `MapOr`
- `MapOrElse`
- `And`
- `AndThen`
- `Contains`
- `Flatten`
